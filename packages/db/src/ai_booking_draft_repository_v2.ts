/**
 * AI Booking Draft Repository
 *
 * CRUD for structured booking drafts generated by AI from customer messages.
 * The instructor reviews pending drafts and confirms or rejects them.
 */

import { sql } from './client.js';

// ── Types ────────────────────────────────────────────────────────────────────

export type BookingDraftStatus = 'pending_review' | 'confirmed' | 'rejected' | 'expired';

export interface AIBookingDraftRow {
  id: string;
  conversation_id: string;
  instructor_id: string;
  message_id: string | null;
  customer_name: string | null;
  customer_phone: string | null;
  booking_date: string; // YYYY-MM-DD
  start_time: string;   // HH:MM:SS
  end_time: string;     // HH:MM:SS
  duration_minutes: number | null;
  party_size: number;
  skill_level: string | null;
  lesson_type: string | null;
  sport: string | null;
  resort: string | null;
  meeting_point_text: string | null;
  service_id: string | null;
  meeting_point_id: string | null;
  raw_extraction: Record<string, unknown>;
  extraction_confidence: number;
  draft_reason: string;
  status: BookingDraftStatus;
  ai_customer_reply: string | null;
  created_at: string;
  reviewed_at: string | null;
  confirmed_booking_id: string | null;
}

// ── Insert ───────────────────────────────────────────────────────────────────

export interface InsertAIBookingDraftParams {
  conversationId: string;
  instructorId: string;
  messageId?: string | null;
  customerName?: string | null;
  customerPhone?: string | null;
  bookingDate: string;   // YYYY-MM-DD
  startTime: string;     // HH:MM
  endTime: string;       // HH:MM
  durationMinutes?: number | null;
  partySize?: number;
  skillLevel?: string | null;
  lessonType?: string | null;
  sport?: string | null;
  resort?: string | null;
  meetingPointText?: string | null;
  serviceId?: string | null;
  meetingPointId?: string | null;
  rawExtraction?: Record<string, unknown>;
  extractionConfidence?: number;
  draftReason?: string;
  aiCustomerReply?: string | null;
}

export async function insertAIBookingDraft(
  params: InsertAIBookingDraftParams
): Promise<AIBookingDraftRow> {
  const rows = await sql<AIBookingDraftRow[]>`
    INSERT INTO ai_booking_drafts (
      conversation_id,
      instructor_id,
      message_id,
      customer_name,
      customer_phone,
      booking_date,
      start_time,
      end_time,
      duration_minutes,
      party_size,
      skill_level,
      lesson_type,
      sport,
      resort,
      meeting_point_text,
      service_id,
      meeting_point_id,
      raw_extraction,
      extraction_confidence,
      draft_reason,
      ai_customer_reply
    ) VALUES (
      ${params.conversationId}::uuid,
      ${params.instructorId}::uuid,
      ${params.messageId ?? null}::uuid,
      ${params.customerName ?? null},
      ${params.customerPhone ?? null},
      ${params.bookingDate}::date,
      ${params.startTime}::time,
      ${params.endTime}::time,
      ${params.durationMinutes ?? null},
      ${params.partySize ?? 1},
      ${params.skillLevel ?? null},
      ${params.lessonType ?? null},
      ${params.sport ?? 'ski'},
      ${params.resort ?? null},
      ${params.meetingPointText ?? null},
      ${params.serviceId ?? null}::uuid,
      ${params.meetingPointId ?? null}::uuid,
      ${JSON.stringify(params.rawExtraction ?? {})}::jsonb,
      ${params.extractionConfidence ?? 0},
      ${params.draftReason ?? 'AI auto-extracted from customer message'},
      ${params.aiCustomerReply ?? null}
    )
    RETURNING *
  `;

  if (rows.length === 0) throw new Error('Failed to insert ai_booking_draft');
  return rows[0];
}

// ── List (for instructor) ────────────────────────────────────────────────────

export async function listAIBookingDrafts(
  instructorId: string,
  opts?: { status?: BookingDraftStatus; limit?: number }
): Promise<AIBookingDraftRow[]> {
  const limit = opts?.limit ?? 50;

  if (opts?.status) {
    return sql<AIBookingDraftRow[]>`
      SELECT * FROM ai_booking_drafts
      WHERE instructor_id = ${instructorId}::uuid
        AND status = ${opts.status}
      ORDER BY created_at DESC
      LIMIT ${limit}
    `;
  }

  return sql<AIBookingDraftRow[]>`
    SELECT * FROM ai_booking_drafts
    WHERE instructor_id = ${instructorId}::uuid
    ORDER BY created_at DESC
    LIMIT ${limit}
  `;
}

// ── Get single ───────────────────────────────────────────────────────────────

export async function getAIBookingDraftById(
  draftId: string,
  instructorId: string
): Promise<AIBookingDraftRow | null> {
  const rows = await sql<AIBookingDraftRow[]>`
    SELECT * FROM ai_booking_drafts
    WHERE id = ${draftId}::uuid
      AND instructor_id = ${instructorId}::uuid
  `;
  return rows.length > 0 ? rows[0] : null;
}

// ── Confirm / Reject ─────────────────────────────────────────────────────────

export async function confirmAIBookingDraft(
  draftId: string,
  instructorId: string,
  confirmedBookingId?: string | null
): Promise<AIBookingDraftRow> {
  const rows = await sql<AIBookingDraftRow[]>`
    UPDATE ai_booking_drafts
    SET status = 'confirmed',
        reviewed_at = now(),
        confirmed_booking_id = ${confirmedBookingId ?? null}::uuid
    WHERE id = ${draftId}::uuid
      AND instructor_id = ${instructorId}::uuid
      AND status = 'pending_review'
    RETURNING *
  `;
  if (rows.length === 0) throw new Error('Draft not found or already reviewed');
  return rows[0];
}

export async function rejectAIBookingDraft(
  draftId: string,
  instructorId: string
): Promise<AIBookingDraftRow> {
  const rows = await sql<AIBookingDraftRow[]>`
    UPDATE ai_booking_drafts
    SET status = 'rejected',
        reviewed_at = now()
    WHERE id = ${draftId}::uuid
      AND instructor_id = ${instructorId}::uuid
      AND status = 'pending_review'
    RETURNING *
  `;
  if (rows.length === 0) throw new Error('Draft not found or already reviewed');
  return rows[0];
}

// ── Count pending (for sidebar badge) ────────────────────────────────────────

export async function countPendingBookingDrafts(
  instructorId: string
): Promise<number> {
  const rows = await sql<Array<{ count: string }>>`
    SELECT count(*)::text FROM ai_booking_drafts
    WHERE instructor_id = ${instructorId}::uuid
      AND status = 'pending_review'
  `;
  return parseInt(rows[0]?.count ?? '0', 10);
}

// ── Pending draft by conversation (for suggested actions) ─────────────────────

export async function getPendingBookingDraftByConversation(
  conversationId: string,
  instructorId: string
): Promise<AIBookingDraftRow | null> {
  const rows = await sql<AIBookingDraftRow[]>`
    SELECT * FROM ai_booking_drafts
    WHERE conversation_id = ${conversationId}::uuid
      AND instructor_id = ${instructorId}::uuid
      AND status = 'pending_review'
    ORDER BY created_at DESC
    LIMIT 1
  `;
  return rows[0] ?? null;
}

/**
 * Confirmed booking IDs for a conversation (from confirmed ai_booking_drafts).
 * Used to find bookings that may need a payment link.
 */
export async function getConfirmedBookingIdsByConversation(
  conversationId: string,
  instructorId: string
): Promise<string[]> {
  const rows = await sql<Array<{ confirmed_booking_id: string }>>`
    SELECT confirmed_booking_id
    FROM ai_booking_drafts
    WHERE conversation_id = ${conversationId}::uuid
      AND instructor_id = ${instructorId}::uuid
      AND status = 'confirmed'
      AND confirmed_booking_id IS NOT NULL
    ORDER BY reviewed_at DESC
  `;
  return rows.map((r) => r.confirmed_booking_id);
}
