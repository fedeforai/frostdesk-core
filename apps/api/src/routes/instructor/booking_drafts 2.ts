/**
 * AI Booking Drafts routes — structured booking proposals generated by AI.
 *
 * GET  /instructor/booking-drafts           → list all drafts (optionally filter by status)
 * GET  /instructor/booking-drafts/count     → count of pending drafts (for badge)
 * GET  /instructor/booking-drafts/:id       → single draft detail
 * POST /instructor/booking-drafts/:id/confirm → confirm draft (→ instructor reviews and creates booking)
 * POST /instructor/booking-drafts/:id/reject  → reject draft
 */

import type { FastifyInstance } from 'fastify';
import {
  getInstructorProfileByUserId,
  listAIBookingDrafts,
  getAIBookingDraftById,
  confirmAIBookingDraftWithAudit,
  rejectAIBookingDraft,
  countPendingBookingDrafts,
  insertAuditEvent,
} from '@frostdesk/db';
import type { BookingDraftStatus } from '@frostdesk/db';
import { randomUUID } from 'node:crypto';
import { getUserIdFromJwt } from '../../lib/auth_instructor.js';
import { normalizeError } from '../../errors/normalize_error.js';
import { mapErrorToHttp } from '../../errors/error_http_map.js';
import { ERROR_CODES } from '../../errors/error_codes.js';

/** Normalize Postgres date/time values to simple strings for the frontend. */
function normalizeDate(v: unknown): string {
  if (!v) return '';
  const s = String(v);
  // Full ISO timestamp → YYYY-MM-DD
  if (s.includes('T')) return s.split('T')[0];
  // Already YYYY-MM-DD or date-like
  return s.slice(0, 10);
}

function normalizeTime(v: unknown): string {
  if (!v) return '';
  const s = String(v);
  // HH:MM:SS → HH:MM
  return s.slice(0, 5);
}

async function getInstructorId(request: { headers?: { authorization?: string } }): Promise<string> {
  const userId = await getUserIdFromJwt(request);
  const profile = await getInstructorProfileByUserId(userId);
  if (!profile) {
    const e = new Error('Instructor profile not found');
    (e as any).code = ERROR_CODES.NOT_FOUND;
    throw e;
  }
  return profile.id;
}

export async function instructorBookingDraftsRoutes(app: FastifyInstance): Promise<void> {
  // ── List drafts ──────────────────────────────────────────────────────────
  app.get('/instructor/booking-drafts', async (request, reply) => {
    try {
      const instructorId = await getInstructorId(request);
      const query = request.query as { status?: string; limit?: string };
      const status = query.status as BookingDraftStatus | undefined;
      const limit = query.limit ? parseInt(query.limit, 10) : 50;

      const drafts = await listAIBookingDrafts(instructorId, { status, limit });

      return reply.send({
        ok: true,
        drafts: drafts.map((d) => ({
          id: d.id,
          conversationId: d.conversation_id,
          messageId: d.message_id,
          customerName: d.customer_name,
          customerPhone: d.customer_phone,
          bookingDate: normalizeDate(d.booking_date),
          startTime: normalizeTime(d.start_time),
          endTime: normalizeTime(d.end_time),
          durationMinutes: d.duration_minutes,
          partySize: d.party_size,
          skillLevel: d.skill_level,
          lessonType: d.lesson_type,
          sport: d.sport,
          resort: d.resort,
          meetingPointText: d.meeting_point_text,
          serviceId: d.service_id,
          meetingPointId: d.meeting_point_id,
          extractionConfidence: d.extraction_confidence,
          draftReason: d.draft_reason,
          status: d.status,
          aiCustomerReply: d.ai_customer_reply,
          createdAt: d.created_at,
          reviewedAt: d.reviewed_at,
          confirmedBookingId: d.confirmed_booking_id,
        })),
      });
    } catch (err) {
      const normalized = normalizeError(err);
      const status = mapErrorToHttp(normalized.error);
      return reply.status(status).send({ ok: false, error: normalized.error, message: normalized.message });
    }
  });

  // ── Count pending (for sidebar badge) ─────────────────────────────────────
  app.get('/instructor/booking-drafts/count', async (request, reply) => {
    try {
      const instructorId = await getInstructorId(request);
      const count = await countPendingBookingDrafts(instructorId);
      return reply.send({ ok: true, count });
    } catch (err) {
      const normalized = normalizeError(err);
      const status = mapErrorToHttp(normalized.error);
      return reply.status(status).send({ ok: false, error: normalized.error, message: normalized.message });
    }
  });

  // ── Get single draft ──────────────────────────────────────────────────────
  app.get('/instructor/booking-drafts/:id', async (request, reply) => {
    try {
      const instructorId = await getInstructorId(request);
      const { id } = request.params as { id: string };
      const draft = await getAIBookingDraftById(id, instructorId);
      if (!draft) {
        return reply.status(404).send({ ok: false, error: 'NOT_FOUND', message: 'Draft not found' });
      }
      return reply.send({ ok: true, draft });
    } catch (err) {
      const normalized = normalizeError(err);
      const status = mapErrorToHttp(normalized.error);
      return reply.status(status).send({ ok: false, error: normalized.error, message: normalized.message });
    }
  });

  // ── Confirm draft → CREATE BOOKING (P2.1 atomic) ────────────────────────
  app.post('/instructor/booking-drafts/:id/confirm', async (request, reply) => {
    try {
      const userId = await getUserIdFromJwt(request);
      const profile = await getInstructorProfileByUserId(userId);
      if (!profile) {
        return reply.status(404).send({ ok: false, error: 'NOT_FOUND', message: 'Instructor profile not found' });
      }
      const instructorId = profile.id;
      const { id: draftId } = request.params as { id: string };

      // Atomic: lock draft → create booking → update draft → audit
      const result = await confirmAIBookingDraftWithAudit({
        draftId,
        instructorId,
        actorUserId: userId,
        requestId: randomUUID(),
        userAgent: request.headers['user-agent'] ?? null,
        ipAddress: request.ip ?? null,
      });

      // Best-effort domain audit event (separate from the transactional audit above)
      try {
        await insertAuditEvent({
          actor_type: 'instructor',
          actor_id: instructorId,
          action: 'ai_booking_draft_confirmed',
          entity_type: 'ai_booking_draft',
          entity_id: draftId,
          severity: 'info',
          payload: {
            booking_id: result.bookingId,
            already_confirmed: result.alreadyConfirmed,
          },
        });
      } catch {
        // Fail-open: audit best-effort
      }

      return reply.send({
        ok: true,
        bookingId: result.bookingId,
        alreadyConfirmed: result.alreadyConfirmed,
      });
    } catch (err) {
      const normalized = normalizeError(err);
      const status = mapErrorToHttp(normalized.error);
      return reply.status(status).send({ ok: false, error: normalized.error, message: normalized.message });
    }
  });

  // ── Reject draft ──────────────────────────────────────────────────────────
  app.post('/instructor/booking-drafts/:id/reject', async (request, reply) => {
    try {
      const instructorId = await getInstructorId(request);
      const { id } = request.params as { id: string };

      const updated = await rejectAIBookingDraft(id, instructorId);

      try {
        await insertAuditEvent({
          actor_type: 'instructor',
          actor_id: instructorId,
          action: 'ai_booking_draft_rejected',
          entity_type: 'ai_booking_draft',
          entity_id: id,
          severity: 'info',
          payload: {
            booking_date: updated.booking_date,
            customer_name: updated.customer_name,
          },
        });
      } catch {
        // Fail-open
      }

      return reply.send({ ok: true, draft: updated });
    } catch (err) {
      const normalized = normalizeError(err);
      const status = mapErrorToHttp(normalized.error);
      return reply.status(status).send({ ok: false, error: normalized.error, message: normalized.message });
    }
  });
}
